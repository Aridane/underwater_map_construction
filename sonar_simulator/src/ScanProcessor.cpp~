#include "ScanProcessor.h"
using namespace std;

ScanProcessor::ScanProcessor(ros::NodeHandle* n){
	ros::NodeHandle nh("~");
	nh.param("mode", mode_, string("SONAR")); //LASER, SONAR, LASER+SONAR
	nh.param("maxBinValue", maxBinValue_, int(255));
	nh.param("thresholdType", thresholdMode_, string("FIXED"));
	nh.param("upsampling", upsamplingMode_, string("MLS+VOXEL_GRID_DILATION"));
	nh.param("outlierRemovalMode", outlierRemovalMode_, string("STATISTICAL"));
	nh.param("thresholdValue", thresholdValue_, int(128));
	nh.param("sonarSubscribeTopic", sonarSubscribeTopic_, string("/sonar"));
	nh.param("sonarCloudPublishTopic", sonarCloudPublishTopic_, string("/Sonar/Scan/SonarCloud"));
	nh.param("laserCloudPublishTopic", laserCloudPublishTopic_, string("/Sonar/Scan/laserCloud"));

	beamSubscriber_ = n->subscribe(sonarSubscribeTopic_.c_str(), 10, &ScanProcessor::beamCallback, this);
	if (mode_.find("LASER") != -1) laserInit(n);
	if (mode_.find("SONAR") != -1) sonarInit(n);
}

void ScanProcessor::laserInit(ros::NodeHandle* n){
	laserCloudPublisher_ = n->advertise<avora_msgs::SonarScanCloud>(laserCloudPublishTopic_, 1);
	laserCloud_ = boost::make_shared<intensityCloud>();
	laserCloudMsg_ = boost::make_shared<avora_msgs::SonarScanCloud>();
}

void ScanProcessor::sonarInit(ros::NodeHandle* n){
	sonarCloudPublisher_ = n->advertise<avora_msgs::SonarScanCloud>(sonarCloudPublishTopic_.c_str(), 1);
	sonarCloud_ = boost::make_shared<intensityCloud>();
	sonarCloudMsg_ = boost::make_shared<avora_msgs::SonarScanCloud>();
	sonarCloudSize_ = 0;
	sonarCloudNBeams_ = 0;
	sonarCloud_->is_dense = true;

}

ScanProcessor::~ScanProcessor(){
}

bool ScanProcessor::hasChanged(avora_msgs::SonarScanLineConstPtr scan, avora_msgs::SonarScanLineConstPtr oldScanLine){
	return (scan->sensorAngle != oldScanLine->sensorAngle);
}

void ScanProcessor::beamCallback(avora_msgs::SonarScanLineConstPtr scanLine){
	double x,y,z;
	pcl::PointXYZI point;
	int max = 0, maxIndex = 0;

	if (mode_.find("LASER") != -1){
		if (hasChanged(scanLine, oldScanLine_)) {
			processLaserCloud();
			publishLaserCloud();
			laserCloud_.reset();
		}
		for (int i=0;i<scanLine->intensities.size();i++){
			if (scanLine->intensities[i] > max){
				max = scanLine->intensities[i];
				maxIndex = i;
			}
		}
		point.x = maxIndex * scanLine->maxrange_meters * cosf(scanLine->angle);
		point.y = maxIndex * scanLine->maxrange_meters * sinf(scanLine->angle);
		point.z = 0;
		point.intensity = scanLine->intensities[maxIndex];

		laserCloud_->push_back(point);
	}

	if (mode_.find("SONAR") != -1){
		if (hasChanged(scanLine, oldScanLine_)) {
			processSonarCloud();
			publishSonarCloud();

			sonarCloud_.reset();
			sonarCloudSize_ = 0;
			sonarCloudNBeams_ = 0;
		}

		for (int i=0;i<scanLine->intensities.size();i++){
			//TODO Put correct values
			point.x = i * scanLine->maxrange_meters * cosf(scanLine->angle);
			point.y = i * scanLine->maxrange_meters * sinf(scanLine->angle);
			point.z = 0;
			point.intensity = scanLine->intensities[i];

			sonarCloud_->push_back(point);
			sonarCloudSize_++;
		}
		sonarCloudNBeams_++;
	}
	oldScanLine_ = scanLine;

}

void ScanProcessor::thresholdCloud(intensityCloud::Ptr cloud){
	if (thresholdMode_ == "OTSU"){
		//OTSU Method
		//Histogram
		std::vector<double> histogram(256,0);
		for (cloudIterator = cloud->begin();cloudIterator != cloud->end();cloudIterator++){
			histogram[cloudIterator->intensity]++;
		}
		double sum = 0;
		for (int i=0 ; i<256 ; i++) sum += i * histogram[i];

		double size = cloud->size();
		double sumB = 0;
		double wB = 0;
		double wF = 0;
		double mB;
		double mF;
		double max = 0.0;
		double between = 0.0;
		double threshold1 = 0.0;
		double threshold2 = 0.0;

		for (int i = 0;i<256;i++){
			wB += histogram[i];
			if (wB == 0) continue;
			wF = size - wB;
			if (wF == 0) break;
			sumB += i * histogram[i];
			mB = sumB / wB;
			mF = (sum - sumB) / wF;
			between = wB * wF * (mB - mF) * (mB - mF);
			if (between >= max){
				threshold1 = i;
				if (between > max)
					threshold2 = i;
				max = between;
			}

		}
		thresholdValue_ = (threshold1 + threshold2) / 2.0;
	}

	for (cloudIterator = cloud->begin();cloudIterator != cloud->end();cloudIterator++){
		if (cloudIterator->intensity < thresholdValue_){
			cloudIterator->intensity = 0;
		}
	}
}

void ScanProcessor::removeCloudOutliers(intensityCloud::Ptr cloud){
	if (outlierRemovalMode_ == "STATISTICAL"){
		// Create the filtering object
		 pcl::StatisticalOutlierRemoval<pcl::PointXYZI> sor;
		 sor.setInputCloud (cloud);
		 // Set the number of nearest neighbors to use for mean distance estimation.
		 sor.setMeanK (50);
		 /* Set the standard deviation multiplier for the distance threshold calculation.
		 	 The distance threshold will be equal to: mean + stddev_mult * stddev.
		 	 Points will be classified as inlier or outlier if their average neighbor
		 	 distance is below or above this threshold respectively.
		 */
		 sor.setStddevMulThresh (1.0);
		 sor.setKeepOrganized(true);
		 sor.filter (*cloud);
	}
	else {
/*		// Create the radius outlier removal filter
		pcl::RadiusOutlierRemoval<pcl::PointXYZI> radius_outlier_removal;
		// Set input cloud
		radius_outlier_removal.setInputCloud (cloud);
		// Set radius for neighbor search
		radius_outlier_removal.setRadiusSearch (0.05);
		// Set threshold for minimum required neighbors neighbors
		radius_outlier_removal.setMinNeighborsInRadius (800);

		radius_outlier_removal.setKeepOrganized(true);
		// Do filtering
		radius_outlier_removal.filter (*cloud);
*/
	}

}

void ScanProcessor::upSampleCloud(intensityCloud::Ptr cloud){
	//Expansion
	if (upsamplingMode_.find("MLS") != -1){

		pcl::PointCloud<pcl::PointXYZRGB>::Ptr tempRGBCloud;
	
		//intensityToRGB(cloud, tempRGBCloud);

		pcl::search::KdTree<pcl::PointXYZRGB>::Ptr tree (new pcl::search::KdTree<pcl::PointXYZRGB>);
		pcl::MovingLeastSquares<pcl::PointXYZRGB, pcl::PointXYZRGB> mls;

		mls.setComputeNormals(false);
		mls.setInputCloud(tempRGBCloud);
		mls.setPolynomialFit(false);
		mls.setSearchMethod(tree);
		mls.setSearchRadius(0.1);

		if (upsamplingMode_.find("NONE") != -1)
			mls.setUpsamplingMethod(pcl::MovingLeastSquares<pcl::PointXYZRGB, pcl::PointXYZRGB>::NONE);
		else if (upsamplingMode_.find("DISTINCT_CLOUD") != -1)
			mls.setUpsamplingMethod(pcl::MovingLeastSquares<pcl::PointXYZRGB, pcl::PointXYZRGB>::DISTINCT_CLOUD);
		else if (upsamplingMode_.find("SAMPLE_LOCAL_PLANE") != -1)
			mls.setUpsamplingMethod(pcl::MovingLeastSquares<pcl::PointXYZRGB, pcl::PointXYZRGB>::SAMPLE_LOCAL_PLANE);
		else if (upsamplingMode_.find("RANDOM_UNIFORM_DENSITY") != -1)
			mls.setUpsamplingMethod(pcl::MovingLeastSquares<pcl::PointXYZRGB, pcl::PointXYZRGB>::RANDOM_UNIFORM_DENSITY);
		else if (upsamplingMode_.find("VOXEL_GRID_DILATION") != -1){
			mls.setUpsamplingMethod(pcl::MovingLeastSquares<pcl::PointXYZRGB, pcl::PointXYZRGB>::VOXEL_GRID_DILATION);
			mls.setDilationVoxelSize(0.003);
		}
		//Upsampled cloud into sonarCloud_
		mls.process(*tempRGBCloud);

		(*rgbCloud, *sonarCloud_);

	} else if (upsamplingMode_ == "Poisson"){

	} else if (upsamplingMode_ == "Bilateral"){

	}
}
// This procedure refines the data from the scan in the following way
// 1 - Threshold values with low intensity
// 2 - Expansion due to sparse data
// 3 - Outlier Removal
// TODO Check if expansion + outlier or outlier + expansion
void ScanProcessor::processSonarCloud(){
	sonarCloud_->height = sonarCloudNBeams_;
	sonarCloud_ ->width = oldScanLine_->intensities.size();
	sonarCloud_->resize(sonarCloud_->height*sonarCloud_ ->width);
	thresholdCloud(sonarCloud_);
	removeCloudOutliers(sonarCloud_);
	upSampleCloud(sonarCloud_);


}

void ScanProcessor::publishSonarCloud(){
	sonarCloudPublisher_.publish(sonarCloudMsg_);
}

void ScanProcessor::processLaserCloud(){
	laserCloudMsg_->gain = oldScanLine_->gain;
	laserCloudMsg_->maxrange_meters = oldScanLine_->maxrange_meters;
	laserCloudMsg_->nBeams = laserCloud_->size();
	laserCloudMsg_->servoAngle = oldScanLine_->angle;

	pcl::toROSMsg(*(laserCloud_.get()), laserCloudMsg_->scan);
}

void ScanProcessor::publishLaserCloud(){
	laserCloudPublisher_.publish(laserCloudMsg_);
}

int main (int argc, char** argv){
	ros::init(argc, argv, "ScanProcessor");
	ros::NodeHandle nh;

	ScanProcessor sonar2scan(&nh);

	while (ros::ok()) {
		ros::spinOnce();
	}

}
