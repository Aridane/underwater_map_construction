#include <ros/ros.h>
#include <ros/console.h>

#include <avora_msgs/SonarScanLine.h>
#include <avora_msgs/SonarScan.h>
#include <avora_msgs/SonarScanCloud.h>

#include <pcl/ros/conversions.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/PCLPointCloud2.h>
#include <pcl/filters/passthrough.h>

#include <string>

typedef pcl::PointCloud<pcl::PointXYZI> intensityCloud;
using namespace std;

class ScanProcessor {
private:
	string mode_; // LASER, SONAR, LASER+SONAR
	string thresholdType_; // OTSU, FIXED
	int thresholdValue_;
	int maxBinValue_;

	avora_msgs::SonarScanCloudPtr laserCloudMsg_;
	avora_msgs::SonarScanCloudPtr sonarCloudMsg_;
	avora_msgs::SonarScanLineConstPtr oldScanLine_;
	intensityCloud::Ptr laserCloud_;
	intensityCloud::iterator itLaser_;
	intensityCloud::Ptr sonarCloud_;
	intensityCloud::iterator itSonar_;
	ros::Subscriber beamSubscriber_;
	ros::Publisher laserCloudPublisher_;
	ros::Publisher sonarCloudPublisher_;
	string beamSubscribeTopic_;
	string sonarCloudPublishTopic_;
	string laserCloudPublishTopic_;


public:
	ScanProcessor(ros::NodeHandle* n);
	~ScanProcessor();
	void laserInit(ros::NodeHandle* n);
	void sonarInit(ros::NodeHandle* n);
	
	void beamCallback(avora_msgs::SonarScanLineConstPtr scanLine);
	bool hasChanged(avora_msgs::SonarScanLineConstPtr scan, avora_msgs::SonarScanLineConstPtr oldScanLine);
	void processLaserCloud();
	void publishLaserCloud();
	void processSonarCloud();
	void publishSonarCloud();
};
